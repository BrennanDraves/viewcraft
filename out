============================= test session starts =============================
platform win32 -- Python 3.11.9, pytest-8.3.4, pluggy-1.5.0
django: version: 5.1.4, settings: demo.settings (from ini)
rootdir: C:\Users\drave\OneDrive\Documents\!personal\Programming\viewcraft
configfile: pyproject.toml
testpaths: tests
plugins: Faker-33.3.0, cov-6.0.0, django-4.9.0, sugar-1.0.0, xdist-3.6.1
collected 54 items

tests\test_components.py ..................                              [ 33%]
tests\test_filter.py .........                                           [ 50%]
tests\test_pagination.py ......                                          [ 61%]
tests\test_search.py .FFF..                                              [ 72%]
tests\test_utils.py ...............                                      [100%]

================================== FAILURES ===================================
_________________________ test_basic_search_filtering _________________________

self = <django.db.backends.utils.CursorWrapper object at 0x00000198266E2390>
sql = 'INSERT INTO "demo_app_blogpost" ("title", "slug", "body", "author_id", "status", "category", "tags", "view_count", "l...pdated_at", "published_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "demo_app_blogpost"."id"'
params = ('TEST_UNIQUE_TITLE', 'test-slug', 'Test body', None, 'published', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000198266E2390>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)

.env\Lib\site-packages\django\db\backends\utils.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000019826702570>
query = 'INSERT INTO "demo_app_blogpost" ("title", "slug", "body", "author_id", "status", "category", "tags", "view_count", "l...ated_at", "updated_at", "published_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING "demo_app_blogpost"."id"'
params = ('TEST_UNIQUE_TITLE', 'test-slug', 'Test body', None, 'published', '', ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
E       sqlite3.IntegrityError: NOT NULL constraint failed: demo_app_blogpost.author_id

.env\Lib\site-packages\django\db\backends\sqlite3\base.py:354: IntegrityError

The above exception was the direct cause of the following exception:

search_view_class = <class 'tests.test_search.search_view_class.<locals>.TestSearchView'>
rf = <django.test.client.RequestFactory object at 0x00000198266E2290>
blog_posts = [<BlogPost: Blog Post 0>, <BlogPost: Blog Post 1>, <BlogPost: Blog Post 2>, <BlogPost: Blog Post 3>, <BlogPost: Blog Post 4>]

    def test_basic_search_filtering(search_view_class, rf, blog_posts):
        """Test basic search filtering."""
        # Create a blog post with a specific title for testing
        test_title = "TEST_UNIQUE_TITLE"
>       BlogPost.objects.create(
            title=test_title,
            slug="test-slug",
            body="Test body",
            status="published"
        )

tests\test_search.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.env\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
.env\Lib\site-packages\django\db\models\query.py:679: in create
    obj.save(force_insert=True, using=self.db)
.env\Lib\site-packages\django\db\models\base.py:892: in save
    self.save_base(
.env\Lib\site-packages\django\db\models\base.py:998: in save_base
    updated = self._save_table(
.env\Lib\site-packages\django\db\models\base.py:1161: in _save_table
    results = self._do_insert(
.env\Lib\site-packages\django\db\models\base.py:1202: in _do_insert
    return manager._insert(
.env\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
.env\Lib\site-packages\django\db\models\query.py:1847: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
.env\Lib\site-packages\django\db\models\sql\compiler.py:1836: in execute_sql
    cursor.execute(sql, params)
.env\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
.env\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
.env\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
.env\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
.env\Lib\site-packages\django\db\backends\utils.py:105: in _execute
    return self.cursor.execute(sql, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000019826702570>
query = 'INSERT INTO "demo_app_blogpost" ("title", "slug", "body", "author_id", "status", "category", "tags", "view_count", "l...ated_at", "updated_at", "published_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING "demo_app_blogpost"."id"'
params = ('TEST_UNIQUE_TITLE', 'test-slug', 'Test body', None, 'published', '', ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
E       django.db.utils.IntegrityError: NOT NULL constraint failed: demo_app_blogpost.author_id

.env\Lib\site-packages\django\db\backends\sqlite3\base.py:354: IntegrityError
_________________________ test_search_form_in_context _________________________

search_view = <tests.test_search.search_view_class.<locals>.TestSearchView object at 0x00000198284E9650>
rf = <django.test.client.RequestFactory object at 0x00000198284E9710>

    def test_search_form_in_context(search_view, rf):
        """Test that search form is added to context."""
        view = search_view
>       context = view.get_context_data()

tests\test_search.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
viewcraft\views.py:222: in wrapped
    return self._run_hook_chain(hook_method, *args, **kwargs)
viewcraft\views.py:158: in _run_hook_chain
    result = self._call_parent_method(hook, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tests.test_search.search_view_class.<locals>.TestSearchView object at 0x00000198284E9650>
hook = <HookMethod.GET_CONTEXT_DATA: 'get_context_data'>, args = (), kwargs = {}
parent_method = <bound method MultipleObjectMixin.get_context_data of <tests.test_search.search_view_class.<locals>.TestSearchView object at 0x00000198284E9650>>

    def _call_parent_method(self, hook: HookMethod, *args: Any, **kwargs: Any) -> Any:
        """
        Call the original method implementation from the parent class.
    
        Attempts to call the parent class's implementation of the hooked method,
        handling cases where the method might not exist.
    
        Args:
            hook: The hook method being executed
            *args: Method arguments
            **kwargs: Method keyword arguments
    
        Returns:
            Any: The result of the parent method
    
        Raises:
            NotImplementedError: If the parent class doesn't implement the method
        """
        try:
            parent_method = getattr(super(), hook.value)
            return parent_method(*args, **kwargs)
        except AttributeError:
            # If parent doesn't implement the method, raise NotImplementedError
            # This matches Django's default behavior
>           raise NotImplementedError(
                f"Method {hook.value} not implemented on parent class"
            ) from None
E           NotImplementedError: Method get_context_data not implemented on parent class

viewcraft\views.py:196: NotImplementedError
_________________________ test_multiple_field_search __________________________

self = <django.db.backends.utils.CursorWrapper object at 0x00000198265580D0>
sql = 'INSERT INTO "demo_app_blogpost" ("title", "slug", "body", "author_id", "status", "category", "tags", "view_count", "l...pdated_at", "published_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING "demo_app_blogpost"."id"'
params = ('Multiple Field Test', 'multiple-field-test', 'Special test content', None, 'published', 'Test Category', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='sqlite' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x00000198265580D0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        # Raise a warning during app initialization (stored_app_configs is only
        # ever set during testing).
        if not apps.ready and not apps.stored_app_configs:
            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)

.env\Lib\site-packages\django\db\backends\utils.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000019827BD9010>
query = 'INSERT INTO "demo_app_blogpost" ("title", "slug", "body", "author_id", "status", "category", "tags", "view_count", "l...ated_at", "updated_at", "published_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING "demo_app_blogpost"."id"'
params = ('Multiple Field Test', 'multiple-field-test', 'Special test content', None, 'published', 'Test Category', ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
E       sqlite3.IntegrityError: NOT NULL constraint failed: demo_app_blogpost.author_id

.env\Lib\site-packages\django\db\backends\sqlite3\base.py:354: IntegrityError

The above exception was the direct cause of the following exception:

search_view_class = <class 'tests.test_search.search_view_class.<locals>.TestSearchView'>
rf = <django.test.client.RequestFactory object at 0x000001982655A350>
blog_posts = [<BlogPost: Blog Post 0>, <BlogPost: Blog Post 1>, <BlogPost: Blog Post 2>, <BlogPost: Blog Post 3>, <BlogPost: Blog Post 4>]

    def test_multiple_field_search(search_view_class, rf, blog_posts):
        """Test search with multiple fields."""
        # Create a specific post for testing
>       BlogPost.objects.create(
            title="Multiple Field Test",
            slug="multiple-field-test",
            body="Special test content",
            status="published",
            category="Test Category"
        )

tests\test_search.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.env\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
.env\Lib\site-packages\django\db\models\query.py:679: in create
    obj.save(force_insert=True, using=self.db)
.env\Lib\site-packages\django\db\models\base.py:892: in save
    self.save_base(
.env\Lib\site-packages\django\db\models\base.py:998: in save_base
    updated = self._save_table(
.env\Lib\site-packages\django\db\models\base.py:1161: in _save_table
    results = self._do_insert(
.env\Lib\site-packages\django\db\models\base.py:1202: in _do_insert
    return manager._insert(
.env\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
.env\Lib\site-packages\django\db\models\query.py:1847: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
.env\Lib\site-packages\django\db\models\sql\compiler.py:1836: in execute_sql
    cursor.execute(sql, params)
.env\Lib\site-packages\django\db\backends\utils.py:79: in execute
    return self._execute_with_wrappers(
.env\Lib\site-packages\django\db\backends\utils.py:92: in _execute_with_wrappers
    return executor(sql, params, many, context)
.env\Lib\site-packages\django\db\backends\utils.py:100: in _execute
    with self.db.wrap_database_errors:
.env\Lib\site-packages\django\db\utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
.env\Lib\site-packages\django\db\backends\utils.py:105: in _execute
    return self.cursor.execute(sql, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000019827BD9010>
query = 'INSERT INTO "demo_app_blogpost" ("title", "slug", "body", "author_id", "status", "category", "tags", "view_count", "l...ated_at", "updated_at", "published_at") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING "demo_app_blogpost"."id"'
params = ('Multiple Field Test', 'multiple-field-test', 'Special test content', None, 'published', 'Test Category', ...)

    def execute(self, query, params=None):
        if params is None:
            return super().execute(query)
        # Extract names if params is a mapping, i.e. "pyformat" style is used.
        param_names = list(params) if isinstance(params, Mapping) else None
        query = self.convert_query(query, param_names=param_names)
>       return super().execute(query, params)
E       django.db.utils.IntegrityError: NOT NULL constraint failed: demo_app_blogpost.author_id

.env\Lib\site-packages\django\db\backends\sqlite3\base.py:354: IntegrityError
=========================== short test summary info ===========================
FAILED tests/test_search.py::test_basic_search_filtering - django.db.utils.In...
FAILED tests/test_search.py::test_search_form_in_context - NotImplementedErro...
FAILED tests/test_search.py::test_multiple_field_search - django.db.utils.Int...
======================== 3 failed, 51 passed in 1.55s =========================
